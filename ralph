# Ralph Wiggum Technique - Implementation Guide

## Overview
Ralph Wiggum (named after The Simpsons character) is an autonomous AI coding methodology that runs agents in a continuous loop until tasks are verifiably complete. Instead of one-shot prompting, Ralph iterates repeatedly, using test failures and external verification as feedback until the work actually succeeds.

## Core Concept

```bash
while (task_not_complete) {
  run_agent(task)
  check_completion_criteria()
  if (not_complete) {
    load_context_from_files()
    iterate_again()
  }
}
```

## How It Works

### 1. Define Clear Completion Criteria
Specify what "done" looks like with objective, verifiable conditions:
- Tests passing (coverage > 80%)
- Builds successfully
- Specific features implemented
- Output includes completion promise: `<promise>COMPLETE</promise>`

### 2. Agent Attempts Task
AI works on the task, accessing:
- Previous git commits
- Test results
- Modified files
- Error messages

### 3. Stop Hook Blocks Premature Exit
When agent tries to exit, system intercepts and checks completion criteria. If not met, reloads prompt and starts new iteration.

### 4. Backpressure Provides Feedback
Objective signals guide the agent:
- **Tests**: Pass/fail feedback
- **Linters**: Code quality checks
- **Builds**: Compilation errors
- **Type checkers**: Type safety validation

### 5. Iteration Continues
Same prompt fed back with updated context. Agent sees results of previous attempt and tries again.

## Key Components

### Completion Promise
Agent must output specific marker when done:
```
<promise>COMPLETE</promise>
```

### Max Iterations
Safety limit prevents infinite loops:
```bash
--max-iterations 50
```

### Backpressure
External validation that can't be gamed:
- Running tests and checking exit codes
- Build success/failure
- Linter output
- File existence checks

### Fresh Context Per Iteration
Each loop starts clean, avoiding context pollution. State persists through:
- Git history
- Modified files
- Test output
- Progress tracking files

## Implementation Pattern

### Basic Structure
```bash
#!/bin/bash

MAX_ITERATIONS=50
ITERATION=0

while [ $ITERATION -lt $MAX_ITERATIONS ]; do
  ITERATION=$((ITERATION + 1))
  
  # Run agent with task
  claude code -p "$(cat PROMPT.md)" > output.txt
  
  # Check for completion promise
  if grep -q "<promise>COMPLETE</promise>" output.txt; then
    echo "Task complete in $ITERATION iterations"
    exit 0
  fi
  
  # Otherwise, loop continues with updated file state
done

echo "Max iterations reached without completion"
exit 1
```

### Task Prompt Template
```markdown
# Task
Build a visa interview coach agent with bilingual Hindi/English support.

# Requirements
- Agent asks interview questions in English
- Switches to Hindi when student shows confusion
- Provides feedback after session
- Handles 10+ common visa question types

# Completion Criteria
- All tests passing (coverage > 80%)
- Agent correctly detects confusion signals
- Language switching works bidirectionally
- Session feedback is generated properly

# Instructions
Work on ONE requirement at a time. After implementing, run tests. If tests fail, fix and retry. Commit when tests pass.

When ALL requirements are complete and tests pass, output:
<promise>COMPLETE</promise>
```

## Best Practices

### 1. Small, Verifiable Tasks
Break work into chunks completable in one context window (10-30 minutes of agent work).

### 2. Objective Completion Criteria
Don't rely on agent self-assessment. Use:
- ✅ "All tests pass"
- ✅ "Build succeeds"
- ✅ "Coverage > 80%"
- ❌ "Code looks good"
- ❌ "Seems complete"

### 3. Clear Backpressure
Make tests/validation easy to run:
```bash
npm test        # Should return clear pass/fail
npm run lint    # Should catch quality issues
npm run build   # Should verify compilation
```

### 4. One Task Per Iteration
Prompt should enforce single-task focus:
- "Work on ONE task only"
- "Commit when tests pass"
- "Don't move to next task until current passes"

### 5. Human-in-the-Loop First
Start by watching iterations manually before going fully autonomous:
```bash
# Run once, observe
./ralph-once.sh

# Check what it did
git diff
git log -1

# Run again
./ralph-once.sh
```

### 6. Reasonable Max Iterations
- Simple tasks: 5-10 iterations
- Medium tasks: 20-30 iterations
- Complex tasks: 40-50 iterations

## Application to Visa Interview Coach

### Example Ralph Loop Setup

**PROMPT.md:**
```markdown
You are building an AI visa interview coach for Indian students.

CURRENT TASK: Implement bilingual language switching

REQUIREMENTS:
1. Agent asks questions in English by default
2. Detects confusion signals (long pauses, "I don't understand", "Hindi mein samjhao")
3. Switches to Hindi to explain question
4. Re-asks same question in English after explanation
5. Logs all language switches for feedback

COMPLETION CRITERIA:
- Tests pass for confusion detection
- Hindi explanations are clear and accurate
- Questions are re-asked in English after Hindi help
- Session summary includes language switch count

Run tests with: npm test
After tests pass, commit changes.

When complete, output: <promise>COMPLETE</promise>
```

**Run Command:**
```bash
/ralph-loop "$(cat PROMPT.md)" \
  --max-iterations 30 \
  --completion-promise "COMPLETE"
```

### Iterative Development Flow

**Iteration 1:** Agent implements basic confusion detection
- Tests fail: doesn't catch "Hindi mein samjhao"
- Agent reads test output, sees failure

**Iteration 2:** Agent adds Hindi trigger phrase detection
- Tests pass for detection
- Tests fail: Hindi explanation not implemented
- Agent reads failure, continues

**Iteration 3:** Agent implements Hindi explanation logic
- Tests pass for Hindi switching
- Tests fail: doesn't re-ask in English
- Agent sees pattern, fixes

**Iteration 4:** Agent implements English re-prompting
- All tests pass
- Agent outputs `<promise>COMPLETE</promise>`
- Loop exits

## Common Pitfalls

### ❌ Vague Completion Criteria
"Make it better" → Agent never knows when to stop

### ❌ No Backpressure
Without tests, agent can claim success without verification

### ❌ Tasks Too Large
If task requires 100+ changes, agent runs out of context

### ❌ Trusting Self-Assessment
Agent thinks it's done ≠ actually done

### ✅ Solutions
- Write specific, testable requirements
- Add comprehensive test coverage
- Break large tasks into smaller chunks
- Use external verification (tests, builds, lints)

## Why Ralph Works

1. **Iteration beats perfection**: Don't expect perfect first try
2. **External truth**: Tests/builds can't be hallucinated
3. **Fresh context**: Each iteration starts clean, no context pollution
4. **Persistent learning**: Git history and files carry knowledge forward
5. **Autonomous refinement**: Agent self-corrects based on objective feedback

## Summary

Ralph Wiggum = **Continuous iteration with external verification until objectively complete**

Perfect for:
- Building features with clear acceptance criteria
- Refactoring with test coverage
- Migrations with verifiable completion
- Any task where "done" can be objectively measured

Not for:
- Creative/subjective work without objective criteria
- Tasks requiring human judgment
- One-off scripts where iteration overhead isn't worth it

---

**The Ralph Philosophy**: Like the character, fail repeatedly but never give up. Let the loop handle persistence while you handle specification.